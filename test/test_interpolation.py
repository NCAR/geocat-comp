import sys
import unittest
import random
from unittest import TestCase

import geocat.datafiles as gdf
import numpy as np
import numpy.testing as nt
import numpy.ma as ma
import xarray as xr

# Import from directory structure if coverage test, or from installed
# packages otherwise
if "--cov" in str(sys.argv):
    from src.geocat.comp import interp_wrap, interp_hybrid_to_pressure, interp_sigma_to_hybrid, ChunkError, CoordinateError
else:
    from geocat.comp import interp_wrap, interp_hybrid_to_pressure, interp_sigma_to_hybrid, ChunkError, CoordinateError

# Global input data

# Open the netCDF data file "atmos.nc" and read in common variables
try:
    ds_atmos = xr.open_dataset(gdf.get("netcdf_files/atmos.nc"),
                               decode_times=False)
except:
    ds_atmos = xr.open_dataset("test/atmos.nc", decode_times=False)

_hyam = ds_atmos.hyam
_hybm = ds_atmos.hybm
_p0 = 1000. * 100  # Pa


class Test_interp_hybrid_to_pressure(TestCase):

    # Sample input data
    data = ds_atmos.U[0, :, :, :]
    ps = ds_atmos.PS
    pres3d = np.asarray([1000, 950, 800, 700, 600, 500, 400, 300, 200])  # mb
    pres3d = pres3d * 100  # mb to Pa

    # Expected output from above sample input

    try:
        ds_out = xr.open_dataset(
            "vinth2p_output.nc"
        )  # Generated by running ncl_tests/vinth2p_test_conwomap_5.ncl on atmos.nc
    except:
        ds_out = xr.open_dataset("test/vinth2p_output.nc")

    uzon_expected = ds_out.uzon  # Expected output
    u_int_expected = ds_out.u_int  # Expected output

    def test_interp_hybrid_to_pressure_atmos(self):
        u_int = interp_hybrid_to_pressure(self.data,
                                          self.ps[0, :, :],
                                          _hyam,
                                          _hybm,
                                          p0=_p0,
                                          new_levels=self.pres3d,
                                          method="log")

        uzon = u_int.mean(dim='lon')

        nt.assert_array_almost_equal(self.uzon_expected, uzon, 5)

    def test_interp_hybrid_to_pressure_atmos_4d(self):
        data_t = self.data.expand_dims("time")

        u_int = interp_hybrid_to_pressure(data_t,
                                          self.ps,
                                          _hyam,
                                          _hybm,
                                          p0=_p0,
                                          new_levels=self.pres3d,
                                          method="log")

        uzon = u_int.mean(dim='lon')

        uzon_expected_t = self.uzon_expected.expand_dims("time")
        nt.assert_array_almost_equal(uzon_expected_t, uzon, 5)

    def test_interp_hybrid_to_pressure_atmos_wrong_method(self):
        with nt.assert_raises(ValueError):
            u_int = interp_hybrid_to_pressure(self.data,
                                              self.ps[0, :, :],
                                              _hyam,
                                              _hybm,
                                              p0=_p0,
                                              new_levels=self.pres3d,
                                              method="wrong_method")

    def test_interp_hybrid_to_pressure_atmos_dask(self):

        ps_dask = self.ps.chunk()
        data_dask = self.data.chunk()

        u_int = interp_hybrid_to_pressure(data_dask,
                                          ps_dask[0, :, :],
                                          _hyam,
                                          _hybm,
                                          p0=_p0,
                                          new_levels=self.pres3d,
                                          method="log")

        uzon = u_int.mean(dim='lon')

        nt.assert_array_almost_equal(self.uzon_expected, uzon, 5)


class Test_interp_sigma_to_hybrid(TestCase):

    hyam = xr.DataArray([0.0108093, 0.0130731, 0.03255911, 0.0639471])
    hybm = xr.DataArray([0.0108093, 0.0173664, 0.06069280, 0.1158237])

    # Open the netCDF data file "u.89335.1.nc" and read in input data
    try:
        ds_u = xr.open_dataset(
            gdf.get("netcdf_files/u.89335.1_subset_time361.nc"),
            decode_times=False)
    except:
        ds_u = xr.open_dataset("test/u.89335.1_subset_time361.nc",
                               decode_times=False)

    u = ds_u.u[:, 0:3, 0:2]

    # Open the netCDF data file "ps.89335.1.nc" and read in additional input data
    try:
        ds_ps = xr.open_dataset(gdf.get("netcdf_files/ps.89335.1.nc"),
                                decode_times=False)
    except:
        ds_ps = xr.open_dataset("test/ps.89335.1.nc", decode_times=False)

    ps = ds_ps.ps[361, 0:3, 0:2] * 100  # Pa
    sigma = ds_ps.sigma

    # Expected output from above sample input
    try:
        ds_out = xr.open_dataset(
            "sigma2hybrid_output.nc"
        )  # Generated by running ncl_tests/test_sigma2hybrid.ncl
    except:
        ds_out = xr.open_dataset("test/sigma2hybrid_output.nc")

    xh_expected = ds_out.xh.transpose("ncl3", "ncl1", "ncl2")  # Expected output

    def test_interp_sigma_to_hybrid_1d(self):
        xh = interp_sigma_to_hybrid(self.u[:, 0, 0],
                                    self.sigma,
                                    self.ps[0, 0],
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(self.xh_expected[:, 0, 0], xh, 5)

    def test_interp_sigma_to_hybrid_3d(self):
        xh = interp_sigma_to_hybrid(self.u,
                                    self.sigma,
                                    self.ps,
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(self.xh_expected, xh, 5)

    def test_interp_sigma_to_hybrid_3d_transposed(self):
        xh = interp_sigma_to_hybrid(self.u.transpose('ycoord', 'sigma',
                                                     'xcoord'),
                                    self.sigma,
                                    self.ps.transpose('ycoord', 'xcoord'),
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(
            self.xh_expected.transpose('ncl2', 'ncl3', 'ncl1'), xh, 5)

    def test_interp_sigma_to_hybrid_3d_dask(self):

        ps_dask = self.ps.chunk()
        u_dask = self.u.chunk()

        xh = interp_sigma_to_hybrid(u_dask,
                                    self.sigma,
                                    ps_dask,
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(self.xh_expected, xh, 5)

    def test_interp_sigma_to_hybrid_wrong_method(self):
        with nt.assert_raises(ValueError):
            xh = interp_sigma_to_hybrid(self.u,
                                        self.sigma,
                                        self.ps,
                                        self.hyam,
                                        self.hybm,
                                        p0=_p0,
                                        method="wrong_method")


class Test_interp_manually_calc(unittest.TestCase):

    @classmethod
    def setUp(cls):
        cls.data_in = np.asarray([
            0.8273209, 0.97402306, 0.49829999, 0.97088771, 0.14578397,
            0.18818199, 0.69280023, 0.37583487, 0.72259201, 0.34248486
        ])
        cls.lon_in = np.arange(0, 360, 36)
        cls.lon_out = np.arange(0, 360 - 35, 18)

        cls.data_out = np.asarray([
            0.8273209, 0.90067198, 0.97402306, 0.736161525, 0.49829999,
            0.73459385, 0.97088771, 0.55833584, 0.14578397, 0.16698298,
            0.18818199, 0.44049111, 0.69280023, 0.53431755, 0.37583487,
            0.54921344, 0.72259201, 0.532538435, 0.34248486
        ])

        cls.data_in_2d = np.asarray([[
            0.8273209, 0.97402306, 0.49829999, 0.97088771, 0.14578397,
            0.18818199, 0.69280023, 0.37583487, 0.72259201, 0.34248486
        ],
                                     [
                                         2.8273209, 2.97402306, 2.49829999,
                                         2.97088771, 2.14578397, 2.18818199,
                                         2.69280023, 2.37583487, 2.72259201,
                                         2.34248486
                                     ],
                                     [
                                         4.8273209, 4.97402306, 4.49829999,
                                         4.97088771, 4.14578397, 4.18818199,
                                         4.69280023, 4.37583487, 4.72259201,
                                         4.34248486
                                     ]])
        cls.lat_in = np.asarray([0, 2, 4])
        cls.lat_out = np.asarray([0, 1, 2, 3, 4])

        cls.data_out_2d = np.asarray(
            [[
                0.8273209, 0.90067198, 0.97402306, 0.736161525, 0.49829999,
                0.73459385, 0.97088771, 0.55833584, 0.14578397, 0.16698298,
                0.18818199, 0.44049111, 0.69280023, 0.53431755, 0.37583487,
                0.54921344, 0.72259201, 0.532538435, 0.34248486
            ],
             [
                 1.8273209, 1.90067198, 1.97402306, 1.736161525, 1.49829999,
                 1.73459385, 1.97088771, 1.55833584, 1.14578397, 1.16698298,
                 1.18818199, 1.44049111, 1.69280023, 1.53431755, 1.37583487,
                 1.54921344, 1.72259201, 1.532538435, 1.34248486
             ],
             [
                 2.8273209, 2.90067198, 2.97402306, 2.736161525, 2.49829999,
                 2.73459385, 2.97088771, 2.55833584, 2.14578397, 2.16698298,
                 2.18818199, 2.44049111, 2.69280023, 2.53431755, 2.37583487,
                 2.54921344, 2.72259201, 2.532538435, 2.34248486
             ],
             [
                 3.8273209, 3.90067198, 3.97402306, 3.736161525, 3.49829999,
                 3.73459385, 3.97088771, 3.55833584, 3.14578397, 3.16698298,
                 3.18818199, 3.44049111, 3.69280023, 3.53431755, 3.37583487,
                 3.54921344, 3.72259201, 3.532538435, 3.34248486
             ],
             [
                 4.8273209, 4.90067198, 4.97402306, 4.736161525, 4.49829999,
                 4.73459385, 4.97088771, 4.55833584, 4.14578397, 4.16698298,
                 4.18818199, 4.44049111, 4.69280023, 4.53431755, 4.37583487,
                 4.54921344, 4.72259201, 4.532538435, 4.34248486
             ]])

        cls.data_in_1d_xr = xr.DataArray(cls.data_in,
                                         dims=["lon"],
                                         coords={"lon": cls.lon_in})

        cls.data_in_2d_xr = xr.DataArray(cls.data_in_2d,
                                         dims=["x", "y"],
                                         coords={
                                             "x": cls.lat_in,
                                             "y": cls.lon_in
                                         })

        cls.msg_py = 55.55

    def test_numpy_1d(self):
        np.testing.assert_almost_equal(
            self.data_out,
            interp_wrap(self.data_in, lon_in=self.lon_in, lon_out=self.lon_out),
            10)

    def test_numpy_1d_cyclic(self):
        x = np.append(self.lon_out, self.lon_in[-1] + 1)
        # calculate cyclic point using linear interp formula
        x_x1 = x[-1] - self.lon_in[-1]
        y2_y1 = self.data_in[0] - self.data_in[-1]
        x2_x1 = self.lon_in[-1] + (abs(self.lon_in[-1] -
                                       self.lon_in[-2])) - self.lon_in[-1]
        cyclic_point = self.data_in[-1] + (x_x1 * y2_y1) / x2_x1
        odata = np.append(self.data_out, cyclic_point)
        nt.assert_almost_equal(
            odata,
            interp_wrap(self.data_in,
                        lon_out=x,
                        lon_in=self.lon_in,
                        cyclic=True), 7)

    def test_numpy_1d_msg(self):
        rand = random.randint(1, len(self.data_in) - 2)
        idata = self.data_in
        odata = self.data_out
        idata[rand] = self.msg_py
        odata[rand * 2] = self.msg_py
        odata[rand * 2 - 1] = self.msg_py
        odata[rand * 2 + 1] = self.msg_py
        np.testing.assert_almost_equal(
            odata,
            interp_wrap(idata,
                        lon_out=self.lon_out,
                        lon_in=self.lon_in,
                        missing_val=self.msg_py), 10)

    def test_numpy_1d_mask(self):
        rand = random.randint(1, len(self.data_in) - 2)
        mask = np.zeros(len(self.data_in))
        mask_out = np.zeros(len(self.data_out))
        mask[rand] = 1
        mask_out[rand * 2] = 1
        mask_out[rand * 2 - 1] = 1
        mask_out[rand * 2 + 1] = 1
        np.testing.assert_almost_equal(
            ma.masked_array(self.data_out, mask_out),
            interp_wrap(data_in=ma.masked_array(self.data_in, mask),
                        lon_out=self.lon_out,
                        lon_in=self.lon_in), 10)

    def test_numpy_1d_nan(self):
        rand = random.randint(1, len(self.data_in) - 2)
        idata = self.data_in
        odata = self.data_out
        idata[rand] = np.nan
        odata[rand * 2] = np.nan
        odata[rand * 2 - 1] = np.nan
        odata[rand * 2 + 1] = np.nan
        np.testing.assert_almost_equal(
            odata, interp_wrap(idata, lon_out=self.lon_out, lon_in=self.lon_in),
            10)

    def test_numpy_2d_float32(self):
        data_in = self.data_in_2d.astype(np.float32)
        data_out = self.data_out_2d.astype(np.float32)
        np.testing.assert_almost_equal(
            data_out,
            interp_wrap(data_in,
                        lon_in=self.lon_in,
                        lat_in=self.lat_in,
                        lon_out=self.lon_out,
                        lat_out=self.lat_out), 6)

    def test_numpy_2d_float64(self):
        data_in = self.data_in_2d.astype(np.float64)
        data_out = self.data_out_2d.astype(np.float64)
        np.testing.assert_almost_equal(
            data_out,
            interp_wrap(data_in,
                        lon_in=self.lon_in,
                        lat_in=self.lat_in,
                        lon_out=self.lon_out,
                        lat_out=self.lat_out), 6)

    def test_numpy_2d_cyclic(self):
        x = np.append(self.lon_out, self.lon_in[-1] + 1)
        odata = np.pad(self.data_out_2d, ((0, 0), (0, 1)))
        # calculate cyclic points using bilinear interp formula
        for i in [0, 1, 2]:
            x_x1 = x[-1] - self.lon_in[-1]
            y2_y1 = self.data_in_2d[i][0] - self.data_in_2d[i][-1]
            x2_x1 = self.lon_in[-1] + (abs(self.lon_in[-1] -
                                           self.lon_in[-2])) - self.lon_in[-1]
            cyclic_point = self.data_in_2d[i][-1] + (x_x1 * y2_y1) / x2_x1
            odata[i * 2][-1] = cyclic_point
        for i in [1, 3]:
            x_x1 = self.lat_out[i] - self.lat_in[int(i / 2)]
            y2_y1 = odata[(int(i / 2) + 1) * 2][-1] - odata[int(i / 2) * 2][-1]
            x2_x1 = self.lat_in[int(i / 2) + 1] - self.lat_in[int(i / 2)]
            cyclic_point = odata[int(i / 2) * 2][-1] + (x_x1 * y2_y1) / x2_x1
            odata[i][-1] = cyclic_point
        np.testing.assert_almost_equal(
            odata,
            interp_wrap(self.data_in_2d,
                        lat_in=self.lat_in,
                        lat_out=self.lat_out,
                        lon_out=x,
                        lon_in=self.lon_in,
                        cyclic=True), 10)

    def test_numpy_2d_missing(self):
        rand_r = random.randint(1, len(self.data_in_2d) - 2)
        rand_c = random.randint(2, len(self.data_in_2d[0]) - 2)
        idata = self.data_in_2d
        idata[rand_r][rand_c] = self.msg_py
        odata = self.data_out_2d
        for i in [0, 1, 2, 3, 4]:
            for j in [(rand_c * 2) - 1, rand_c * 2, (rand_c * 2) + 1,
                      (rand_c * 2) + 2]:
                odata[i][j] = self.msg_py
        np.testing.assert_almost_equal(
            odata,
            interp_wrap(idata,
                        lon_out=self.lon_out,
                        lat_out=self.lat_out,
                        lat_in=self.lat_in,
                        lon_in=self.lon_in,
                        missing_val=self.msg_py), 7)

    def test_numpy_2d_nan(self):
        rand_r = random.randint(1, len(self.data_in_2d) - 2)
        rand_c = random.randint(2, len(self.data_in_2d[0]) - 2)
        idata = self.data_in_2d
        idata[rand_r][rand_c] = np.nan
        odata = self.data_out_2d
        for i in [0, 1, 2, 3, 4]:
            for j in [(rand_c * 2) - 1, rand_c * 2, (rand_c * 2) + 1,
                      (rand_c * 2) + 2]:
                odata[i][j] = np.nan
        np.testing.assert_almost_equal(odata,
                                       interp_wrap(idata,
                                                   lat_in=self.lat_in,
                                                   lat_out=self.lat_out,
                                                   lon_out=self.lon_out,
                                                   lon_in=self.lon_in),
                                       decimal=7)

    def test_numpy_2d_mask(self):
        rand_r = random.randint(1, len(self.data_in_2d) - 2)
        rand_c = random.randint(2, len(self.data_in_2d[0]) - 2)
        mask = np.zeros(self.data_in_2d.shape)
        mask[rand_r][rand_c] = 1
        mask_out = np.zeros(self.data_out_2d.shape)
        for i in [0, 1, 2, 3, 4]:
            for j in [(rand_c * 2) - 1, rand_c * 2, (rand_c * 2) + 1,
                      (rand_c * 2) + 2]:
                mask_out[i][j] = 1
        np.testing.assert_almost_equal(ma.masked_array(self.data_out_2d,
                                                       mask_out),
                                       interp_wrap(ma.masked_array(
                                           self.data_in_2d, mask),
                                                   lat_in=self.lat_in,
                                                   lat_out=self.lat_out,
                                                   lon_out=self.lon_out,
                                                   lon_in=self.lon_in),
                                       decimal=10)

    def test_xarray_1d(self):
        np.testing.assert_almost_equal(
            self.data_out, interp_wrap(self.data_in_1d_xr,
                                       lon_out=self.lon_out), 10)

    def test_xarray_2d_float64(self):
        data_in = self.data_in_2d.astype(np.float64)
        data_in_xr = xr.DataArray(data_in,
                                  dims=["lat", "lon"],
                                  coords={
                                      "lat": self.lat_in,
                                      "lon": self.lon_in
                                  })
        data_out = self.data_out_2d.astype(np.float64)
        np.testing.assert_almost_equal(
            data_out,
            interp_wrap(data_in_xr, lon_out=self.lon_out, lat_out=self.lat_out),
            6)


class Test__interp_larger_dataset(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        dataset = xr.load_dataset("interpolation_test_data.nc")
        cls.input = dataset["__xarray_dataarray_variable__"]

        dataset = xr.load_dataset("interpolation_output_data.nc")
        cls.output = dataset["__xarray_dataarray_variable__"]

        cls.lat10 = np.flip(
            np.arange(np.amin(cls.input.coords["lat"]),
                      np.amax(cls.input.coords["lat"]) + 0.1, 0.1))
        cls.lon10 = np.arange(np.amin(cls.input.coords["lon"]),
                              np.amax(cls.input.coords["lon"]) + 0.1, 0.1)

        cls.input_chunked = xr.DataArray(np.random.rand(3, 96, 37, 19),
                                         dims=["time", "level", "lat", "lon"],
                                         coords={
                                             "lat": np.arange(0, 361, 10),
                                             "lon": np.arange(0, 181, 10)
                                         })
        chunks = {"time": 1, "level": 1, "lat": 37, "lon": 19}
        cls.input_chunked.chunk(chunks)

    def test_10x(self):
        np.testing.assert_array_equal(
            self.output,
            interp_wrap(self.input, lon_out=self.lon10, lat_out=self.lat10))

    # def test_10x_res(self):
    #     np.testing.assert_array_equal(self.input.values, interp_wrap(self.input, lon_out=self.lat10,
    #                                                                  lat_out=self.lon10).values[::10, ::10])

    def test_chunked(self):
        np.testing.assert_almost_equal(
            self.input_chunked.values,
            interp_wrap(self.input_chunked,
                        lat_out=np.arange(0, 361, 5),
                        lon_out=np.arange(0, 181, 5)).values[:, :, ::2, ::2],
            10)


class Test_wrap_errors(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.data_in_1d = np.random.rand(10)
        cls.data_in_2d = np.random.rand(10, 10)
        cls.input_chunk = xr.DataArray(np.random.rand(3, 96, 37, 19),
                                       dims=["time", "level", "lat", "lon"],
                                       coords={
                                           "lat": np.arange(0, 361, 10),
                                           "lon": np.arange(0, 181, 10)
                                       })
        chunks = {"time": 1, "level": 1, "lat": 18, "lon": 18}
        cls.input_chunk.chunk(chunks)

    def test_coordinate_error_1d(self):
        np.testing.assert_raises(CoordinateError, interp_wrap, self.data_in_1d,
                                 np.arange(0, 10, 0.5))

    def test_coordinate_error_2d(self):
        self.assertRaises(CoordinateError, interp_wrap, self.data_in_2d,
                          np.arange(0, 10, 0.5), np.arange(0, 10, 0.5))

    def test_chunk_error(self):
        with nt.assert_raises(ChunkError):
            interp_wrap(data_in=self.input_chunk,
                        lon_out=np.arange(0, 361, 5),
                        lat_out=np.arange(0, 361, 5))
