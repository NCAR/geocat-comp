import sys

import geocat.datafiles as gdf
import numpy as np
import numpy.testing as nt
import xarray as xr
import pytest

from geocat.comp import interp_multidim, interp_hybrid_to_pressure, interp_sigma_to_hybrid

# Global input data

# Open the netCDF data file "atmos.nc" and read in common variables
try:
    ds_atmos = xr.open_dataset(gdf.get("netcdf_files/atmos.nc"),
                               decode_times=False)
except:
    ds_atmos = xr.open_dataset("test/atmos.nc", decode_times=False)

_hyam = ds_atmos.hyam
_hybm = ds_atmos.hybm
_p0 = 1000. * 100  # Pa


class Test_interp_hybrid_to_pressure:

    # Expected output from above sample input
    @pytest.fixture(scope="class")
    def ds_out(self):
        try:
            return xr.open_dataset(
                "vinth2p_output.nc"
            )  # Generated by running ncl_tests/vinth2p_test_conwomap_5.ncl on
        # atmos.nc
        except:
            return xr.open_dataset("test/vinth2p_output.nc")

    # Sample input data
    data = ds_atmos.U[0, :, :, :]
    ps = ds_atmos.PS
    pres3d = np.asarray([1000, 950, 800, 700, 600, 500, 400, 300, 200])  # mb
    pres3d = pres3d * 100  # mb to Pa

    def test_interp_hybrid_to_pressure_atmos(self, ds_out) -> None:
        u_int = interp_hybrid_to_pressure(self.data,
                                          self.ps[0, :, :],
                                          _hyam,
                                          _hybm,
                                          p0=_p0,
                                          new_levels=self.pres3d,
                                          method="log")

        uzon = u_int.mean(dim='lon')

        nt.assert_array_almost_equal(ds_out.uzon, uzon, 5)

    def test_interp_hybrid_to_pressure_atmos_4d(self, ds_out) -> None:
        data_t = self.data.expand_dims("time")

        u_int = interp_hybrid_to_pressure(data_t,
                                          self.ps,
                                          _hyam,
                                          _hybm,
                                          p0=_p0,
                                          new_levels=self.pres3d,
                                          method="log")

        uzon = u_int.mean(dim='lon')

        uzon_expected_t = ds_out.uzon.expand_dims("time")
        nt.assert_array_almost_equal(uzon_expected_t, uzon, 5)

    def test_interp_hybrid_to_pressure_atmos_wrong_method(self) -> None:
        with pytest.raises(ValueError):
            u_int = interp_hybrid_to_pressure(self.data,
                                              self.ps[0, :, :],
                                              _hyam,
                                              _hybm,
                                              p0=_p0,
                                              new_levels=self.pres3d,
                                              method="wrong_method")

    def test_interp_hybrid_to_pressure_atmos_dask(self, ds_out) -> None:

        ps_dask = self.ps.chunk()
        data_dask = self.data.chunk()

        u_int = interp_hybrid_to_pressure(data_dask,
                                          ps_dask[0, :, :],
                                          _hyam,
                                          _hybm,
                                          p0=_p0,
                                          new_levels=self.pres3d,
                                          method="log")

        uzon = u_int.mean(dim='lon')

        nt.assert_array_almost_equal(ds_out.uzon, uzon, 5)


class Test_interp_hybrid_to_pressure_extrapolate:

    @pytest.fixture(scope="class")
    def ds_ccsm(self):
        # Open the netCDF data file with the input data
        try:
            return xr.open_dataset(
                gdf.get("netcdf_files/ccsm35.h0.0021-01.demo.nc"),
                decode_times=False)
        except:
            return xr.open_dataset("test/ccsm35.h0.0021-01.demo.nc",
                                   decode_times=False)

    @pytest.fixture(scope="class")
    def ds_out(self):
        # Open the netCDF file with the output data from running vinth2p_ecmwf.ncl
        try:
            return xr.open_dataset("test/vinth2p_ecmwf_output.nc",
                                   decode_times=False)
        except:
            return xr.open_dataset("vinth2p_ecmwf_output.nc",
                                   decode_times=False)

    @pytest.fixture(scope="class")
    def _hyam(self, ds_ccsm):
        return ds_ccsm.hyam

    @pytest.fixture(scope="class")
    def _hybm(self, ds_ccsm):
        return ds_ccsm.hybm

    @pytest.fixture(scope="class")
    def temp_in(self, ds_ccsm):
        return ds_ccsm.T[:, :, :3, :2]

    @pytest.fixture(scope="class")
    def t_bot(self, ds_ccsm):
        return ds_ccsm.TS[:, :3, :2]

    @pytest.fixture(scope="class")
    def geopotential_in(self, ds_ccsm):
        return ds_ccsm.Z3[:, :, :3, :2]

    @pytest.fixture(scope="class")
    def humidity_in(self, ds_ccsm):
        return ds_ccsm.Q[:, :, :3, :2] * 1000  # g/kg

    @pytest.fixture(scope="class")
    def press_in(self, ds_ccsm):
        return ds_ccsm.PS[:, :3, :2]

    @pytest.fixture(scope="class")
    def phis(self, ds_ccsm):
        return ds_ccsm.PHIS[:, :3, :2]

    new_levels = np.asarray([500, 925, 950, 1000])
    new_levels *= 100  # new levels in Pa
    _p0 = 1000 * 100  # reference pressure in Pa

    def test_interp_hybrid_to_pressure_interp_temp(self, temp_in, press_in,
                                                   _hyam, _hybm,
                                                   ds_out) -> None:
        result = interp_hybrid_to_pressure(temp_in,
                                           press_in,
                                           _hyam,
                                           _hybm,
                                           p0=self._p0,
                                           new_levels=self.new_levels,
                                           method="linear")
        result = result.transpose('time', 'plev', 'lat', 'lon')
        result = result.assign_coords(dict(plev=self.new_levels / 100))
        temp_interp_expected = ds_out.Tp.rename(lev_p='plev')
        xr.testing.assert_allclose(temp_interp_expected, result)

    def test_interp_hybrid_to_pressure_extrap_temp(self, temp_in, press_in,
                                                   _hyam, _hybm, t_bot, phis,
                                                   ds_out) -> None:
        result = interp_hybrid_to_pressure(temp_in,
                                           press_in,
                                           _hyam,
                                           _hybm,
                                           p0=self._p0,
                                           new_levels=self.new_levels,
                                           method="linear",
                                           extrapolate=True,
                                           variable='temperature',
                                           t_bot=t_bot,
                                           phi_sfc=phis)
        result = result.transpose('time', 'plev', 'lat', 'lon')
        result = result.assign_coords(dict(plev=self.new_levels / 100))
        temp_extrap_expected = ds_out.Tpx.rename(lev_p='plev')
        xr.testing.assert_allclose(temp_extrap_expected, result)

    def test_interp_hybrid_to_pressure_extrap_geopotential(
            self, geopotential_in, press_in, _hyam, _hybm, t_bot, phis,
            ds_out) -> None:
        result = interp_hybrid_to_pressure(geopotential_in,
                                           press_in,
                                           _hyam,
                                           _hybm,
                                           p0=self._p0,
                                           new_levels=self.new_levels,
                                           method="linear",
                                           extrapolate=True,
                                           variable='geopotential',
                                           t_bot=t_bot,
                                           phi_sfc=phis)
        result = result.transpose('time', 'plev', 'lat', 'lon')
        result = result.assign_coords(dict(plev=self.new_levels / 100))
        geopotential_extrap_expected = ds_out.Zpx.rename(lev_p='plev')
        xr.testing.assert_allclose(geopotential_extrap_expected, result)

    def test_interp_hybrid_to_pressure_extrap_other(self, humidity_in, press_in,
                                                    _hyam, _hybm, t_bot, phis,
                                                    ds_out) -> None:
        result = interp_hybrid_to_pressure(humidity_in,
                                           press_in,
                                           _hyam,
                                           _hybm,
                                           p0=self._p0,
                                           new_levels=self.new_levels,
                                           method="linear",
                                           extrapolate=True,
                                           variable='other',
                                           t_bot=t_bot,
                                           phi_sfc=phis)
        result = result.transpose('time', 'plev', 'lat', 'lon')
        result = result.assign_coords(dict(plev=self.new_levels / 100))
        humidity_extrap_expected = ds_out.Qpx.rename(lev_p='plev')
        xr.testing.assert_allclose(humidity_extrap_expected, result)

    def test_interp_hybrid_to_pressure_extrap_kwargs(self, humidity_in,
                                                     press_in, _hyam,
                                                     _hybm) -> None:
        with pytest.raises(ValueError):
            interp_hybrid_to_pressure(humidity_in,
                                      press_in,
                                      _hyam,
                                      _hybm,
                                      p0=self._p0,
                                      new_levels=self.new_levels,
                                      method="linear",
                                      extrapolate=True)

    def test_interp_hybrid_to_pressure_extrap_invalid_var(
            self, humidity_in, press_in, _hyam, _hybm, t_bot, phis) -> None:
        with pytest.raises(ValueError):
            interp_hybrid_to_pressure(humidity_in,
                                      press_in,
                                      _hyam,
                                      _hybm,
                                      p0=self._p0,
                                      new_levels=self.new_levels,
                                      method="linear",
                                      extrapolate=True,
                                      variable=' ',
                                      t_bot=t_bot,
                                      phi_sfc=phis)


class Test_interp_sigma_to_hybrid:

    @pytest.fixture(scope="class")
    def ds_u(self):
        # Open the netCDF data file "u.89335.1.nc" and read in input data
        try:
            return xr.open_dataset(
                gdf.get("netcdf_files/u.89335.1_subset_time361.nc"),
                decode_times=False)
        except:
            return xr.open_dataset("test/u.89335.1_subset_time361.nc",
                                   decode_times=False)

    @pytest.fixture(scope="class")
    def ds_ps(self):
        # Open the netCDF data file "ps.89335.1.nc" and read in additional input
        # data
        try:
            return xr.open_dataset(gdf.get("netcdf_files/ps.89335.1.nc"),
                                   decode_times=False)
        except:
            return xr.open_dataset("test/ps.89335.1.nc", decode_times=False)

    @pytest.fixture(scope="class")
    def ds_out(self):
        # Expected output from above sample input
        try:
            return xr.open_dataset(
                "sigma2hybrid_output.nc"
            )  # Generated by running ncl_tests/test_sigma2hybrid.ncl
        except:
            return xr.open_dataset("test/sigma2hybrid_output.nc")

    hyam = xr.DataArray([0.0108093, 0.0130731, 0.03255911, 0.0639471])
    hybm = xr.DataArray([0.0108093, 0.0173664, 0.06069280, 0.1158237])

    @pytest.fixture(scope="class")
    def u(self, ds_u):
        return ds_u.u[:, 0:3, 0:2]

    @pytest.fixture(scope="class")
    def ps(self, ds_ps):
        return ds_ps.ps[361, 0:3, 0:2] * 100  # Pa

    @pytest.fixture(scope="class")
    def sigma(self, ds_ps):
        return ds_ps.sigma

    @pytest.fixture(scope="class")
    def xh_expected(self, ds_out):
        return ds_out.xh.transpose("ncl3", "ncl1", "ncl2")  # Expected output

    def test_interp_sigma_to_hybrid_1d(self, u, sigma, ps, xh_expected) -> None:
        xh = interp_sigma_to_hybrid(u[:, 0, 0],
                                    sigma,
                                    ps[0, 0],
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(xh_expected[:, 0, 0], xh, 5)

    def test_interp_sigma_to_hybrid_3d(self, u, sigma, ps, xh_expected) -> None:
        xh = interp_sigma_to_hybrid(u,
                                    sigma,
                                    ps,
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(xh_expected, xh, 5)

    def test_interp_sigma_to_hybrid_3d_transposed(self, u, sigma, ps,
                                                  xh_expected) -> None:
        xh = interp_sigma_to_hybrid(u.transpose('ycoord', 'sigma', 'xcoord'),
                                    sigma,
                                    ps.transpose('ycoord', 'xcoord'),
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(
            xh_expected.transpose('ncl2', 'ncl3', 'ncl1'), xh, 5)

    def test_interp_sigma_to_hybrid_3d_dask(self, ps, u, sigma,
                                            xh_expected) -> None:

        ps_dask = ps.chunk()
        u_dask = u.chunk()

        xh = interp_sigma_to_hybrid(u_dask,
                                    sigma,
                                    ps_dask,
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(xh_expected, xh, 5)

    def test_interp_sigma_to_hybrid_wrong_method(self, u, sigma, ps) -> None:
        with pytest.raises(ValueError):
            xh = interp_sigma_to_hybrid(u,
                                        sigma,
                                        ps,
                                        self.hyam,
                                        self.hybm,
                                        p0=_p0,
                                        method="wrong_method")


class Test_interp_manually_calc:

    @pytest.fixture(scope="class")
    def test_input(self):
        return xr.load_dataset(
            gdf.get("netcdf_files/interpolation_test_input_data.nc"))

    @pytest.fixture(scope="class")
    def test_output(self):
        return xr.load_dataset(
            gdf.get("netcdf_files/interpolation_test_output_data.nc"))

    @pytest.fixture(scope="class")
    def data_in(self, test_input):
        return test_input['normal']

    @pytest.fixture(scope="class")
    def data_out(self, test_output):
        return test_output['normal']

    @pytest.fixture(scope="class")
    def data_in_nan(self, test_input):
        return test_input['nan']

    @pytest.fixture(scope="class")
    def data_out_nan(self, test_output):
        return test_output['nan']

    @pytest.fixture(scope="class")
    def data_in_nan_2(self, test_input):
        return test_input['nan_2']

    @pytest.fixture(scope="class")
    def data_out_nan_2(self, test_output):
        return test_output['nan_2']

    @pytest.fixture(scope="class")
    def data_in_missing(self, test_input):
        return test_input['missing']

    @pytest.fixture(scope="class")
    def data_out_missing(self, test_output):
        return test_output['missing']

    @pytest.fixture(scope="class")
    def data_in_mask(self, test_input):
        return test_input['mask']

    @pytest.fixture(scope="class")
    def data_out_mask(self, test_output):
        return test_output['mask']

    def test_float32(self, data_in, data_out) -> None:
        np.testing.assert_almost_equal(data_out.values.astype(np.float32),
                                       interp_multidim(xr.DataArray(
                                           data_in.values.astype(np.float32),
                                           dims=['lat', 'lon'],
                                           coords={
                                               'lat': data_in['lat'].values,
                                               'lon': data_in['lon'].values,
                                           }),
                                                       data_out['lat'].values,
                                                       data_out['lon'].values,
                                                       cyclic=True).values,
                                       decimal=7)

    def test_float64(self, data_in, data_out) -> None:
        np.testing.assert_almost_equal(
            data_out.values.astype(np.float64),
            interp_multidim(
                xr.DataArray(data_in.values.astype(np.float64),
                             dims=['lat', 'lon'],
                             coords={
                                 'lat': data_in['lat'].values,
                                 'lon': data_in['lon'].values,
                             }),
                data_out['lat'].values,
                data_out['lon'].values,
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_missing(self, data_out, data_out_missing, data_in_missing) -> None:
        np.testing.assert_almost_equal(
            data_out_missing,
            interp_multidim(
                data_in_missing,
                data_out['lat'].values,
                data_out['lon'].values,
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_nan(self, data_out_nan, data_in_nan, data_out) -> None:
        np.testing.assert_almost_equal(
            data_out_nan,
            interp_multidim(
                data_in_nan,
                data_out['lat'].values,
                data_out['lon'].values,
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_mask(self, data_out_mask, data_in_mask, data_out) -> None:
        np.testing.assert_almost_equal(
            data_out_mask,
            interp_multidim(
                data_in_mask,
                data_out['lat'].values,
                data_out['lon'].values,
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_2_nans(self, data_out_nan_2, data_in_nan_2, data_out) -> None:
        np.testing.assert_almost_equal(
            data_out_nan_2,
            interp_multidim(
                data_in_nan_2,
                data_out['lat'].values,
                data_out['lon'].values,
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_numpy(self, data_out, data_in) -> None:
        np.testing.assert_almost_equal(data_out.values,
                                       interp_multidim(
                                           data_in.values,
                                           data_out['lat'].values,
                                           data_out['lon'].values,
                                           lat_in=data_in['lat'].values,
                                           lon_in=data_in['lon'].values,
                                           cyclic=True,
                                       ),
                                       decimal=8)

    def test_extrapolate(self, data_out, data_in) -> None:
        np.testing.assert_almost_equal(data_out.values,
                                       interp_multidim(
                                           data_in,
                                           data_out['lat'].values,
                                           data_out['lon'].values,
                                           cyclic=True,
                                           fill_value='extrapolate',
                                       ),
                                       decimal=8)


class Test_interp_larger_dataset:

    @pytest.fixture(scope="class")
    def test_input(self):
        return xr.load_dataset(
            gdf.get("netcdf_files/spherical_noise_input.nc"))['spherical_noise']

    @pytest.fixture(scope="class")
    def test_output(self):
        return xr.load_dataset(gdf.get(
            "netcdf_files/spherical_noise_output.nc"))['spherical_noise']

    def test_10x(self, test_input, test_output) -> None:
        data_xr = interp_multidim(test_input, test_output.coords['lat'],
                                  test_output.coords['lon'])
        np.testing.assert_almost_equal(
            test_output,
            data_xr.values,
            decimal=8,
        )

    def test_chunked(self, test_input, test_output) -> None:
        data_xr = interp_multidim(test_input.chunk(2),
                                  test_output.coords['lat'],
                                  test_output.coords['lon'])

        np.testing.assert_almost_equal(test_output, data_xr.values, decimal=8)
