import sys
import unittest
from unittest import TestCase

import geocat.datafiles as gdf
import numpy as np
import numpy.testing as nt
import xarray as xr

# Import from directory structure if coverage test, or from installed
# packages otherwise
if "--cov" in str(sys.argv):
    from src.geocat.comp import interp_wrap, interp_hybrid_to_pressure, \
        interp_sigma_to_hybrid
else:
    from geocat.comp import interp_wrap, interp_hybrid_to_pressure, \
        interp_sigma_to_hybrid

# Global input data

# Open the netCDF data file "atmos.nc" and read in common variables
try:
    ds_atmos = xr.open_dataset(gdf.get("netcdf_files/atmos.nc"),
                               decode_times=False)
except:
    ds_atmos = xr.open_dataset("test/atmos.nc", decode_times=False)

_hyam = ds_atmos.hyam
_hybm = ds_atmos.hybm
_p0 = 1000. * 100  # Pa


class Test_interp_hybrid_to_pressure(TestCase):
    # Sample input data
    data = ds_atmos.U[0, :, :, :]
    ps = ds_atmos.PS
    pres3d = np.asarray([1000, 950, 800, 700, 600, 500, 400, 300, 200])  # mb
    pres3d = pres3d * 100  # mb to Pa

    # Expected output from above sample input

    try:
        ds_out = xr.open_dataset(
            "vinth2p_output.nc"
        )  # Generated by running ncl_tests/vinth2p_test_conwomap_5.ncl on
        # atmos.nc
    except:
        ds_out = xr.open_dataset("test/vinth2p_output.nc")

    uzon_expected = ds_out.uzon  # Expected output
    u_int_expected = ds_out.u_int  # Expected output

    def test_interp_hybrid_to_pressure_atmos(self):
        u_int = interp_hybrid_to_pressure(self.data,
                                          self.ps[0, :, :],
                                          _hyam,
                                          _hybm,
                                          p0=_p0,
                                          new_levels=self.pres3d,
                                          method="log")

        uzon = u_int.mean(dim='lon')

        nt.assert_array_almost_equal(self.uzon_expected, uzon, 5)

    def test_interp_hybrid_to_pressure_atmos_4d(self):
        data_t = self.data.expand_dims("time")

        u_int = interp_hybrid_to_pressure(data_t,
                                          self.ps,
                                          _hyam,
                                          _hybm,
                                          p0=_p0,
                                          new_levels=self.pres3d,
                                          method="log")

        uzon = u_int.mean(dim='lon')

        uzon_expected_t = self.uzon_expected.expand_dims("time")
        nt.assert_array_almost_equal(uzon_expected_t, uzon, 5)

    def test_interp_hybrid_to_pressure_atmos_wrong_method(self):
        with nt.assert_raises(ValueError):
            u_int = interp_hybrid_to_pressure(self.data,
                                              self.ps[0, :, :],
                                              _hyam,
                                              _hybm,
                                              p0=_p0,
                                              new_levels=self.pres3d,
                                              method="wrong_method")

    def test_interp_hybrid_to_pressure_atmos_dask(self):

        ps_dask = self.ps.chunk()
        data_dask = self.data.chunk()

        u_int = interp_hybrid_to_pressure(data_dask,
                                          ps_dask[0, :, :],
                                          _hyam,
                                          _hybm,
                                          p0=_p0,
                                          new_levels=self.pres3d,
                                          method="log")

        uzon = u_int.mean(dim='lon')

        nt.assert_array_almost_equal(self.uzon_expected, uzon, 5)


class Test_interp_sigma_to_hybrid(TestCase):
    hyam = xr.DataArray([0.0108093, 0.0130731, 0.03255911, 0.0639471])
    hybm = xr.DataArray([0.0108093, 0.0173664, 0.06069280, 0.1158237])

    # Open the netCDF data file "u.89335.1.nc" and read in input data
    try:
        ds_u = xr.open_dataset(
            gdf.get("netcdf_files/u.89335.1_subset_time361.nc"),
            decode_times=False)
    except:
        ds_u = xr.open_dataset("test/u.89335.1_subset_time361.nc",
                               decode_times=False)

    u = ds_u.u[:, 0:3, 0:2]

    # Open the netCDF data file "ps.89335.1.nc" and read in additional input
    # data
    try:
        ds_ps = xr.open_dataset(gdf.get("netcdf_files/ps.89335.1.nc"),
                                decode_times=False)
    except:
        ds_ps = xr.open_dataset("test/ps.89335.1.nc", decode_times=False)

    ps = ds_ps.ps[361, 0:3, 0:2] * 100  # Pa
    sigma = ds_ps.sigma

    # Expected output from above sample input
    try:
        ds_out = xr.open_dataset(
            "sigma2hybrid_output.nc"
        )  # Generated by running ncl_tests/test_sigma2hybrid.ncl
    except:
        ds_out = xr.open_dataset("test/sigma2hybrid_output.nc")

    xh_expected = ds_out.xh.transpose("ncl3", "ncl1", "ncl2")  # Expected output

    def test_interp_sigma_to_hybrid_1d(self):
        xh = interp_sigma_to_hybrid(self.u[:, 0, 0],
                                    self.sigma,
                                    self.ps[0, 0],
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(self.xh_expected[:, 0, 0], xh, 5)

    def test_interp_sigma_to_hybrid_3d(self):
        xh = interp_sigma_to_hybrid(self.u,
                                    self.sigma,
                                    self.ps,
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(self.xh_expected, xh, 5)

    def test_interp_sigma_to_hybrid_3d_transposed(self):
        xh = interp_sigma_to_hybrid(self.u.transpose('ycoord', 'sigma',
                                                     'xcoord'),
                                    self.sigma,
                                    self.ps.transpose('ycoord', 'xcoord'),
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(
            self.xh_expected.transpose('ncl2', 'ncl3', 'ncl1'), xh, 5)

    def test_interp_sigma_to_hybrid_3d_dask(self):

        ps_dask = self.ps.chunk()
        u_dask = self.u.chunk()

        xh = interp_sigma_to_hybrid(u_dask,
                                    self.sigma,
                                    ps_dask,
                                    self.hyam,
                                    self.hybm,
                                    p0=_p0,
                                    method="linear")
        nt.assert_array_almost_equal(self.xh_expected, xh, 5)

    def test_interp_sigma_to_hybrid_wrong_method(self):
        with nt.assert_raises(ValueError):
            xh = interp_sigma_to_hybrid(self.u,
                                        self.sigma,
                                        self.ps,
                                        self.hyam,
                                        self.hybm,
                                        p0=_p0,
                                        method="wrong_method")


class Test_interp_manually_calc(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.test_input = xr.load_dataset(
            gdf.get("netcdf_files/interpolation_test_input_data.nc"))

        cls.test_output = xr.load_dataset(
            gdf.get("netcdf_files/interpolation_test_output_data.nc"))

        cls.data_in = cls.test_input['normal']
        cls.data_out = cls.test_output['normal']

        cls.lat_in = cls.data_in['lat'].values
        cls.lat_out = cls.data_out['lat'].values
        cls.lon_in = cls.data_in['lon'].values
        cls.lon_out = cls.data_out['lon'].values

        cls.data_in_nan = cls.test_input['nan']
        cls.data_out_nan = cls.test_output['nan']

        cls.data_in_nan_2 = cls.test_input['nan_2']
        cls.data_out_nan_2 = cls.test_output['nan_2']

        cls.data_in_missing = cls.test_input['missing']
        cls.data_out_missing = cls.test_output['missing']

        cls.data_in_mask = cls.test_input['mask']
        cls.data_out_mask = cls.test_output['mask']

    def test_float32(self):
        np.testing.assert_almost_equal(
            self.data_out.values.astype(np.float32),
            interp_wrap(xr.DataArray(self.data_in.values.astype(np.float32),
                                     dims=['lat', 'lon'],
                                     coords={
                                         'lat': self.lat_in,
                                         'lon': self.lon_in,
                                     }),
                        xr.DataArray(dims=['lat', 'lon'],
                                     coords={
                                         'lat': self.lat_out,
                                         'lon': self.lon_out
                                     }),
                        cyclic=True).values,
            decimal=7)

    def test_float64(self):
        np.testing.assert_almost_equal(
            self.data_out.values.astype(np.float64),
            interp_wrap(
                xr.DataArray(self.data_in.values.astype(np.float64),
                             dims=['lat', 'lon'],
                             coords={
                                 'lat': self.lat_in,
                                 'lon': self.lon_in,
                             }),
                xr.DataArray(dims=['lat', 'lon'],
                             coords={
                                 'lat': self.lat_out,
                                 'lon': self.lon_out,
                             }),
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_missing(self):
        np.testing.assert_almost_equal(
            self.data_out_missing,
            interp_wrap(
                self.data_in_missing,
                xr.DataArray(dims=['lat', 'lon'],
                             coords={
                                 'lat': self.lat_out,
                                 'lon': self.lon_out,
                             }),
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_nan(self):
        np.testing.assert_almost_equal(
            self.data_out_nan,
            interp_wrap(
                self.data_in_nan,
                xr.DataArray(dims=['lat', 'lon'],
                             coords={
                                 'lat': self.lat_out,
                                 'lon': self.lon_out,
                             }),
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_mask(self):
        np.testing.assert_almost_equal(
            self.data_out_mask,
            interp_wrap(
                self.data_in_mask,
                xr.DataArray(dims=['lat', 'lon'],
                             coords={
                                 'lat': self.lat_out,
                                 'lon': self.lon_out,
                             }),
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_2_nans(self):
        np.testing.assert_almost_equal(
            self.data_out_nan_2,
            interp_wrap(
                self.data_in_nan_2,
                xr.DataArray(dims=['lat', 'lon'],
                             coords={
                                 'lat': self.lat_out,
                                 'lon': self.lon_out,
                             }),
                cyclic=True,
            ).values,
            decimal=8,
        )

    def test_numpy(self):
        np.testing.assert_almost_equal(self.data_out.values,
                                       interp_wrap(
                                           self.data_in.values,
                                           lat_in=self.lat_in,
                                           lon_in=self.lon_in,
                                           lat_out=self.lat_out,
                                           lon_out=self.lon_out,
                                           cyclic=True,
                                       ),
                                       decimal=8)


class Test_interp_larger_dataset(unittest.TestCase):
    test_input = None
    test_output = None
    test_lat_output = None
    test_lon_output = None
    test_data_chunked = None

    @classmethod
    def setUpClass(cls):
        cls.test_input = xr.load_dataset(
            gdf.get("netcdf_files/spherical_noise_input.nc"))['spherical_noise']

        cls.test_output = xr.load_dataset(
            gdf.get(
                "netcdf_files/spherical_noise_output.nc"))['spherical_noise']

        # cls.test_lat_output = np.arange(
        #     np.min(cls.test_input.coords['lat']),
        #     np.max(cls.test_input.coords['lat']) + 0.1,
        #     0.1,
        # )
        #
        # cls.test_lon_output = np.arange(
        #     np.min(cls.test_input.coords['lon']),
        #     np.max(cls.test_input.coords['lon']) + 0.1,
        #     0.1,
        # )
        cls.test_data_chunked = cls.test_input.chunk(2)

    def test_10x(self):
        data_xr = interp_wrap(
            self.test_input,
            xr.DataArray(dims=self.test_output.dims,
                         coords=self.test_output.coords))
        np.testing.assert_almost_equal(
            self.test_output,
            data_xr.values,
            decimal=8,
        )

    def test_chunked(self):
        data_xr = interp_wrap(
            self.test_data_chunked,
            xr.DataArray(
                dims=self.test_output.dims,
                coords=self.test_output.coords,
            ))

        np.testing.assert_almost_equal(self.test_output,
                                       data_xr.values,
                                       decimal=8)
